2025.11.06.
<br>

## 🤨 접근
### 🧬 로직
- 정점 개수 n받기
- 데이터, 왼쪽자식, 오른쪽 자식 배열 생성하기
- 데이터[, 자식들] 저장
- calculate (계산하는 함수)
    - 만약 데이터가 연산자라면
        - 왼쪽과 오른쪽 결과 먼저 각각 계산
        - 왼쪽과 오른쪽 결과에 대해 사칙연산 수행
    - 만약 연산자 아니고 숫자면 double로 자료형 바꾸어 반환
- 결과물 출력
<br>

### 🔑 전위 / 중위 / 후위 순회
**🧭 트리의 3가지 깊이 우선 탐색 (DFS) 방식**
- 트리를 깊이 우선(DFS)으로 순회하는 3가지 대표적인 방법
- 기준은 "루트(부모) 노드를 언제 방문하는가"

**🥇 전위 순회 (Pre-order Traversal)**
- 순서: 루트(부모) ➡️ 왼쪽 자식 ➡️ 오른쪽 자식
- 예시: `/ 9 - 6 4 3` (방금 푼 문제를 전위 순회로 읽은 값)
> 💡 주요 용도: 트리 복사/저장
> - 트리를 파일에 저장하거나 복제할 때 사용
> - 루트부터 순서대로 저장하면 나중에 그대로 복원하기 쉬움

**🥈 중위 순회 (In-order Traversal)**
- 순서: 왼쪽 자식 ➡️ 루트(부모) ➡️ 오른쪽 자식
- 예시: `9 / (6 - 4) * 3`
> 💡 주요 용도: 이진 탐색 트리(BST) 정렬
> - 이진 탐색 트리(BST)를 중위 순회하면 노드들이 오름차순으로 정렬

**🥉 후위 순회 (Post-order Traversal)**
- 순서: 왼쪽 자식 ➡️ 오른쪽 자식 ➡️ 루트(부모)
- 예시: `9 6 4 - / 3 *` (컴퓨터가 계산하기 쉬움)
> 💡 주요 용도
> - 식 트리(Expression Tree) 계산
>   - 자식 노드(피연산자)들의 값을 먼저 알아야 부모 노드(연산자)의 계산을 수행할 수 있음
> - 파일/폴더 삭제 (메모리 해제)
>   - 자식 노드들을 먼저 삭제(해제)한 뒤, 부모 노드(폴더)를 삭제할 때 사용

<br>

## 🤯 실수
### 접근법 실패
- 완전 이진트리랑 같은 방식으로 하려고 했는데, 자식용 배열이 따로 필요했음... 어제 오늘 접근을 완전 반대로 함

### 출력 위치 잘못 선정
- 내부 for문 안에서 출력을 하려고 해서 null 예외 발생
  <br>

## ✨ 소회
- 확실히 D4 난이도로 오니까 슬슬 어렵다.. 그치만 자료구조는 한 번 익혀놓으면 계속 활용할 수 있다고 생각하기 때문에 열심히 해야겠다…