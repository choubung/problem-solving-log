2025.11.18.
<br>

## 🤨 접근
### 🧬 로직
- dfs 활용
    - 종료 조건: `현재 교환 횟수 == 목표 횟수`
        - 현재 숫자와 지금까지 찾은 `max` 값을 비교하여 갱신
    - 모든 자릿수 $i$와 그 뒤의 모든 자릿수 $j$를 서로 교환
    - 교환한 상태에서 `dfs(현재 교환 횟수 + 1)`을 호출
    - 호출이 끝나면 다시 원상복구(Backtracking)
- 같은 교환 횟수에서, 이미 탐색해본 숫자 조합이라면 다시 탐색하지 않는다
- 예: `(현재 숫자 상태, 교환 횟수)`를 `Set`이나 배열에 저장해두고 체크한다
<br>

## 🤯 실수
### 그리디 접근
다음과 같은 경우에 오답이 발생
- **중복된 숫자가 있을 때의 선택 문제**
    - 예: `32888` (교환 2회)
    - **그리디:** 첫 번째 `3`과 가장 뒤의 `8`을 바꿔 `82883`을 만들고, 그 다음 `2`와 `8`을 바꿔 `88823`을 만들 가능성이 높음
    - **정답:** 첫 번째 `3`과 **가운데** `8`을 먼저 바꾸는 등의 과정을 거쳐 `88832`가 나와야 함. 어떤 `8`을 선택하느냐에 따라 다음 단계의 결과가 달라지는데, 그리디는 당장 눈앞의 최선만 선택하므로 이를 놓침
- **교환 횟수 강제성 (Must Swap)**
    - 이미 숫자가 `99`처럼 내림차순으로 완성되어 있어도, 교환 횟수가 남았다면 **무조건** 바꿔야 함
    - 그리디는 "이미 최대니까 안 바꾼다"라고 판단하거나, 단순히 맨 뒤 두 개만 바꾸는 식으로 처리하기 쉬움

  <br>

## ✨ 소회
- 기초 개념이 좀 빈약한 것 같아서 백트래킹 문제 몇 개 더 풀어봐야겠다.