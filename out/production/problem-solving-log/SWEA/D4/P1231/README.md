2025.11.05.
<br>

## 🤨 접근
### 🧬 로직
- 트리가 갖는 정점의 총 수 N을 입력받는다
- N줄에 걸쳐 주어지는 정보를 배열에 입력받는다
  - 인덱스 입력받기
  - 값 입력받기
  - 배열[인덱스]에 값 저장
- inOrder 함수로 중위순회를 진행한다
  - **inOrder 함수**
    - `pram`: `int index`
    - 만약 인덱스가 트리의 크기 N보다 크다면 리턴
    - 좌측 자식 방문(index*2)
    - 자기 자신 StringBuilder에 추가
    - 우측 자식 방문(index*2+1)
- StringBuilder로 형식을 만든 후 출력
<br>

### 🔑 완전이진트리
**💡 정의**
- 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있는 이진 트리
- 모든 노드들은 왼쪽부터 순서대로 채워짐
> 비교:
>
> - **포화 이진 트리 (Full Binary Tree):** 모든 레벨이 꽉 찬 트리 (완전 이진 트리의 특수한 형태).
> - **그냥 이진 트리:** 마지막 레벨의 노드 왼쪽에 공백이 있으면 완전 이진 트리가 아님.

**⭐ 가장 중요한 특징: 배열과의 완벽한 호환**
- 완전 이진 트리는 `배열(Array)`을 사용해 표현하기에 가장 이상적인 자료구조
- 배열에 저장된 `i`번째 노드를 기준으로 할 때:
  - 부모 노드: `i / 2`
  - 왼쪽 자식 노드: `i * 2`
  - 오른쪽 자식 노드: `i * 2 + 1`

**🎯 주요 활용 예시**
- `힙 (Heap)`
    - 우선순위 큐(Priority Queue)를 구현하는 자료구조
    - 정의 자체가 완전 이진 트리
- `배열 기반 트리 문제`
    - 트리가 완전 이진 트리라는 조건이 주어지면, 배열로 풀라는 힌트
<br>

## 🤯 실수
### 접근법 실패
- 완전 이진 트리이므로 단순 배열로 표현이 가능하다는 것을 간과하고, 2차원 배열로 노드들을 저장하려 함

### tree 배열 크기 설정 실수
- 1번 인덱스부터 트리를 저장할 수 있도록 n(트리크기)+1의 배열을 생성해야 하는데, n 크기의 배열을 생성함
<br>

## ✨ 소회
- 비선형 자료구조를 구현하려니까 확실히 처음에 깔끔하게 생각이 안 난다. 
- 이번에 처음으로 BufferedReader와 StringTokenizer를 써봤는데 앞으로 애용해야겠다.